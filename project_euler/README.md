날짜별 문제풀이 멤버별 로그
============

[설명](https://github.com/GpleLab/training/tree/master/project_euler/etc)
------------

### 2014/11/10
 
#### 이대명
- Java
    - **문제 5번 풀이 완료**  1시간 30분
- 회고 : 어떻게 풀어야 할지 풀이 법이 한참동안 떠오르지 않아서 오래 끌었다.
		junit 테스트에서 ArrayList 의 테스트 하는게 어려움이 있다.

### 2014/11/11
 
#### 이대명
- Java
    - **문제 6번 풀이 완료** 30분
- 회고 : 이번 문제에는 소수구하는거 였는데, 소수관련 문제 3문제 째 나와서 수월하게 풀수있었다.

### 2014/11/13
 
#### 이대명
- Java
    - **문제 7번 풀이 완료** 30분
- 회고 : 이번문제는 단순 계산 문제라서 쉬웠다. 숫자도 큰것이 나올까 걱정햇는데 그런게 아니었다.

#### 조재우
- Swift
    - **문제 1번 풀이 완료**  첫 문제이고, 테스트 환경설정 위주로 하다보니 시간 측정은 못함
- 회고 : Swift 로 처음 풀어봤다. 역시 최근에 iOS 개발한다고 해서 언어에 조금 익숙해졌다고 생각했는데 기본 문법부터 막힌다. TDD 를 위해서 기존에 제공되는 XCTest 외에 [Quick](https://github.com/Quick/Quick) 을 설치했는데, 라이브러리 설치에 조금 애를 먹었다. 앞선 문제들은 쉬우니 차근차근 풀어나가면서 Swift 와 Swift 로 하는 TDD 에 익숙해지자. 역시 TDD는 재밌다 :) (추가, 클로져 개념을 테스트하기 위해서 앞으로 문제 풀이를 클로져로 풀어보는 연습도 차츰 추가해나가야겠다.)

### 2014/11/14

#### 이대명
- Java
    - **문제 8번 풀이 완료** 1시간
- 회고 : 이번문제에서 가장큰 핵심은 데이터를 파싱하는 것인거 같다. 이번문제에서는 엔터키 쳐져있는 것을 한줄로 다 만들어서 String 값으로 받아서 데이터를 파싱하였다. 그거 말고는 최대값 찾는 문제 이다.
 
#### 유병한
- Java
    - **문제 1번 풀이 완료** 1시간
- 회고 : 문제 자체는 쉬웠지만 ItelliJ에서 테스트 환경 설정하고 하는데 조금 헤멧다. 아직은 JUnit에 조금 익숙하지 않은 느낌이다.

#### 조재우
- Swift
    - **문제 2번 풀이 완료** 31분
- 회고 : 어제는 iOS 프로젝트로 만들어서 테스트 할때마다 iOS 시뮬레이터가 켜지는 불상사(?)가 있엇는데 OSX 커맨드라인으로 만들고 다시 테스트 프로젝트 임포트 하니 테스트만 실행하는 것이 가능하게 되었다. 아직 [Quick](https://github.com/Quick/Quick) 에서 제공하는 [Nimble](https://github.com/Quick/Nimble) 매처가 적응이 안된다. 특히 배열 매처는 찾지 못해서 contain(1,2,..) 으로 했는데 이 매처는 그냥 포함 유무만 나타내는 거라서 좀 더 찾아봐야겠다. 피보나치는 굉장히 단순한 문제이지만 ㅎㅎ Swift 로 좀 더 적응기를 가져야겠다!
 
#### 유병한
- Java
    - **문제 4번 풀이 완료** 40분
- 회고
	- 좀 더 효율적으로 풀 수는 없을까 고민이 되는 문제이다. 반복문을 돌면서 모든 경우의 수를 찾는 방법으로 풀었는데 어떤 규칙이 있지 않을까 좀 더 고민해봐야겠다.
	- String을 다룰 때 StringBuilder 클래스를 쓰면 좋은 것 같다. 기존에는 단순히 문자열을 이어 붙일 때 append()만 사용했었는데 reverse() 등 유용한 메서드들 많은거 같다.
	- Math, Collections, Arrays 등과 같이 java에서 기본적으로 제공되는 유틸 클래스 들의 사용법을 익혀 놓아야겠다.

### 2014/11/15

#### 이대명
- Java
    - **문제 9번 풀이 완료** 1시간 40분
- 회고 : a*a + b*b = c*c 라는 피타고라스 수중 조건에 맞는 수를 구하는 문제이다. 이문제에서 복잡한 개념은 없었지만, 어떻게 반복을 할것 인지가 관건 이다. 처음에 a,b,c for 문 3개 돌리려다가 멘붕 왔다가, 변수 하나는 정해지는 거로 수정해서 하니 금방 되었다.
그리고 이번에 JUnit4 의 타임아웃 어노테이션과, assertArrayEquals 를 사용해보았다. 배열, 리스트 비교할때 유용하다.

### 2014/11/17

#### 이대명
- Java
    - **문제 10번 풀이 완료** 1시간 45분
- 회고 : 이번문제는 단순 소수들의 합을 구하는 문제이다. 처음에 빠르게 풀었는데, 시간이 5분정도 걸려서 단축시키려고 수정했는데, 오히려 더 오래 걸렸다. 그래서 다시 고쳐서 했는데, 답이 맞지않아서 계속 해메다가 결국엔 알고보니 int 형으로 하여 자릿수가 넘어서 작게 나오는 것이었다.. 그리고 시간도 단축시켰는데, 소수를 판단하는 함수를 고쳐 시간을 단축 시킬수 있었다. 제곱근을 이용한 방법이다. 제곱근 떨어지는 숫자로 있으면 소수가 아닐것이다.

#### 유병한
- Java
    - **문제 4번 풀이 완료** 
- 회고
	- 입력한 숫자의 최소 공배수를 구하는 문제이다.
	- 일단 풀긴 풀었는데 최소 공배수를 구하는 좀 더 효율적인 방법을 찾아보고 다시 구현해봐야겠다. 언뜻 본내용으로 는 유클리드 호제법으로 최대 공약수를 구한 후 최소 공배수를 구하는 방법이 있던데...

### 2014/11/18

#### 유병한
- Java
    - **문제 6번 풀이 완료** 25분
- 회고
	- 다항식을 이용한 방법으로 문제를 해결했다.
		- 숫자가 두개인 경우
			- 제곱의 합 : a^2 + b^2
			- 합의 제곱 : (a + b)^2 = a^2 + b^2 + 2ab
			- 합의 제곱 - 제곱의 합 : 2ab
		- 숫자가 세개 경우
			- 제곱의 합 : a^2 + b^2 + c^2
			- 합의 제곱 : (a + b + c)^2 = a^2 + b^2 + c^2 + 2ab + 2ac + 2bc = a^2 + b^2 + c^2 + 2(ab + ac + bc) = a^2 + b^2 + c^2 + 2(a(b + c) + bc)
			- 합의 제곱 - 제곱의 합 : 2(a(b + c) + bc)
		- 숫자가 네개 경우
			- 제곱의 합 : a^2 + b^2 + c^2 + d^2
			- 합의 제곱 : (a + b + c + d)^2 = a^2 + b^2 + c^2 + d^2 + 2ab + 2ac + 2ad + 2bc + 2bd + 2cd = a^2 + b^2 + c^2 + d^2 + 2(ab + ac + ad + bc + bd + cd) = a^2 + b^2 + c^2 + d^2 + 2(a(b + c + d) + b(c + d) + cd )
			- 합의 제곱 - 제곱의 합 : 2(a(b + c + d) + b(c + d) + cd )
		- 숫자 a가 10이고 b, c, d, ...로 갈수록 1씩 작아 졌을경우
			- 합의 제곱 - 제곱의 합 : 2(10(9 + 8 + ... + 1) + 9(8 + 7 + ... + 1) + ... + 3(2 + 1) + 2)
		- 숫자 a가 100이고 b, c, d, ...로 갈수록 1씩 작아 졌을경우
			- 합의 제곱 - 제곱의 합 : 2(100(99 + 98 + ... + 1) + 99(98 + 97 + ... + 1) + ... + 3(2 + 1) + 2)
	- 공차가 1인 등차수열의 합
		- 1 + 2 + 3 + ... + n = n(n + 1) / 2

### 2014/11/21

#### 조재우
- Swift
		- **문제 3번 풀이 완료** 1시간
- 회고 : 예비군 때문에 좀 쉬었다가 Swift 로 풀다보니 조금 헤멨다. 소수가 2를 제외하고 홀수라는 점, 예전에 루비로 풀었을땐 다른 방법으로 풀었는데 이번엔 좀 간단히 문제를 풀었다. 루비 코드 분석해서 적용하려다 시간이 좀 오래 걸림. 결국 나중에 소수 문제 다시 나오면 그 문제로 해보기로 했다. arrayMax 함수 구현하면서 arr.reduce(Int.min, { max($0, $1)}) 형태의 함수를 만들었다. 루비의 arr.inject(:+) 와 비슷해보이는 클로저 형태의 구현인데.. 자세한 원리는 좀 더 공부해봐야겠다.
