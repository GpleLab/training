날짜별 문제풀이 멤버별 로그
============

[설명](https://github.com/GpleLab/training/tree/master/project_euler/etc)
------------

### 2014/11/10
 
#### 이대명
- Java
    - **문제 5번 풀이 완료**  1시간 30분
- 회고 : 어떻게 풀어야 할지 풀이 법이 한참동안 떠오르지 않아서 오래 끌었다.
		junit 테스트에서 ArrayList 의 테스트 하는게 어려움이 있다.

### 2014/11/11
 
#### 이대명
- Java
    - **문제 6번 풀이 완료** 30분
- 회고 : 이번 문제에는 소수구하는거 였는데, 소수관련 문제 3문제 째 나와서 수월하게 풀수있었다.

### 2014/11/13
 
#### 이대명
- Java
    - **문제 7번 풀이 완료** 30분
- 회고 : 이번문제는 단순 계산 문제라서 쉬웠다. 숫자도 큰것이 나올까 걱정햇는데 그런게 아니었다.

#### 조재우
- Swift
    - **문제 1번 풀이 완료**  첫 문제이고, 테스트 환경설정 위주로 하다보니 시간 측정은 못함
- 회고 : Swift 로 처음 풀어봤다. 역시 최근에 iOS 개발한다고 해서 언어에 조금 익숙해졌다고 생각했는데 기본 문법부터 막힌다. TDD 를 위해서 기존에 제공되는 XCTest 외에 [Quick](https://github.com/Quick/Quick) 을 설치했는데, 라이브러리 설치에 조금 애를 먹었다. 앞선 문제들은 쉬우니 차근차근 풀어나가면서 Swift 와 Swift 로 하는 TDD 에 익숙해지자. 역시 TDD는 재밌다 :) (추가, 클로져 개념을 테스트하기 위해서 앞으로 문제 풀이를 클로져로 풀어보는 연습도 차츰 추가해나가야겠다.)

### 2014/11/14

#### 이대명
- Java
    - **문제 8번 풀이 완료** 1시간
- 회고 : 이번문제에서 가장큰 핵심은 데이터를 파싱하는 것인거 같다. 이번문제에서는 엔터키 쳐져있는 것을 한줄로 다 만들어서 String 값으로 받아서 데이터를 파싱하였다. 그거 말고는 최대값 찾는 문제 이다.
 
#### 유병한
- Java
    - **문제 1번 풀이 완료** 1시간
- 회고 : 문제 자체는 쉬웠지만 ItelliJ에서 테스트 환경 설정하고 하는데 조금 헤멧다. 아직은 JUnit에 조금 익숙하지 않은 느낌이다.

#### 조재우
- Swift
    - **문제 2번 풀이 완료** 31분
- 회고 : 어제는 iOS 프로젝트로 만들어서 테스트 할때마다 iOS 시뮬레이터가 켜지는 불상사(?)가 있엇는데 OSX 커맨드라인으로 만들고 다시 테스트 프로젝트 임포트 하니 테스트만 실행하는 것이 가능하게 되었다. 아직 [Quick](https://github.com/Quick/Quick) 에서 제공하는 [Nimble](https://github.com/Quick/Nimble) 매처가 적응이 안된다. 특히 배열 매처는 찾지 못해서 contain(1,2,..) 으로 했는데 이 매처는 그냥 포함 유무만 나타내는 거라서 좀 더 찾아봐야겠다. 피보나치는 굉장히 단순한 문제이지만 ㅎㅎ Swift 로 좀 더 적응기를 가져야겠다!
 
#### 유병한
- Java
    - **문제 4번 풀이 완료** 40분
- 회고
	- 좀 더 효율적으로 풀 수는 없을까 고민이 되는 문제이다. 반복문을 돌면서 모든 경우의 수를 찾는 방법으로 풀었는데 어떤 규칙이 있지 않을까 좀 더 고민해봐야겠다.
	- String을 다룰 때 StringBuilder 클래스를 쓰면 좋은 것 같다. 기존에는 단순히 문자열을 이어 붙일 때 append()만 사용했었는데 reverse() 등 유용한 메서드들 많은거 같다.
	- Math, Collections, Arrays 등과 같이 java에서 기본적으로 제공되는 유틸 클래스 들의 사용법을 익혀 놓아야겠다.

### 2014/11/15

#### 이대명
- Java
    - **문제 9번 풀이 완료** 1시간 40분
- 회고 : a*a + b*b = c*c 라는 피타고라스 수중 조건에 맞는 수를 구하는 문제이다. 이문제에서 복잡한 개념은 없었지만, 어떻게 반복을 할것 인지가 관건 이다. 처음에 a,b,c for 문 3개 돌리려다가 멘붕 왔다가, 변수 하나는 정해지는 거로 수정해서 하니 금방 되었다.
그리고 이번에 JUnit4 의 타임아웃 어노테이션과, assertArrayEquals 를 사용해보았다. 배열, 리스트 비교할때 유용하다.

### 2014/11/17

#### 이대명
- Java
    - **문제 10번 풀이 완료** 1시간 45분
- 회고 : 이번문제는 단순 소수들의 합을 구하는 문제이다. 처음에 빠르게 풀었는데, 시간이 5분정도 걸려서 단축시키려고 수정했는데, 오히려 더 오래 걸렸다. 그래서 다시 고쳐서 했는데, 답이 맞지않아서 계속 해메다가 결국엔 알고보니 int 형으로 하여 자릿수가 넘어서 작게 나오는 것이었다.. 그리고 시간도 단축시켰는데, 소수를 판단하는 함수를 고쳐 시간을 단축 시킬수 있었다. 제곱근을 이용한 방법이다. 제곱근 떨어지는 숫자로 있으면 소수가 아닐것이다.

#### 유병한
- Java
    - **문제 4번 풀이 완료** 
- 회고
	- 입력한 숫자의 최소 공배수를 구하는 문제이다.
	- 일단 풀긴 풀었는데 최소 공배수를 구하는 좀 더 효율적인 방법을 찾아보고 다시 구현해봐야겠다. 언뜻 본내용으로 는 유클리드 호제법으로 최대 공약수를 구한 후 최소 공배수를 구하는 방법이 있던데...

### 2014/11/18

#### 유병한
- Java
    - **문제 6번 풀이 완료** 25분
- 회고
	- 다항식을 이용한 방법으로 문제를 해결했다.
		- 숫자가 두개인 경우
			- 제곱의 합 : a^2 + b^2
			- 합의 제곱 : (a + b)^2 = a^2 + b^2 + 2ab
			- 합의 제곱 - 제곱의 합 : 2ab
		- 숫자가 세개 경우
			- 제곱의 합 : a^2 + b^2 + c^2
			- 합의 제곱 : (a + b + c)^2 = a^2 + b^2 + c^2 + 2ab + 2ac + 2bc = a^2 + b^2 + c^2 + 2(ab + ac + bc) = a^2 + b^2 + c^2 + 2(a(b + c) + bc)
			- 합의 제곱 - 제곱의 합 : 2(a(b + c) + bc)
		- 숫자가 네개 경우
			- 제곱의 합 : a^2 + b^2 + c^2 + d^2
			- 합의 제곱 : (a + b + c + d)^2 = a^2 + b^2 + c^2 + d^2 + 2ab + 2ac + 2ad + 2bc + 2bd + 2cd = a^2 + b^2 + c^2 + d^2 + 2(ab + ac + ad + bc + bd + cd) = a^2 + b^2 + c^2 + d^2 + 2(a(b + c + d) + b(c + d) + cd )
			- 합의 제곱 - 제곱의 합 : 2(a(b + c + d) + b(c + d) + cd )
		- 숫자 a가 10이고 b, c, d, ...로 갈수록 1씩 작아 졌을경우
			- 합의 제곱 - 제곱의 합 : 2(10(9 + 8 + ... + 1) + 9(8 + 7 + ... + 1) + ... + 3(2 + 1) + 2)
		- 숫자 a가 100이고 b, c, d, ...로 갈수록 1씩 작아 졌을경우
			- 합의 제곱 - 제곱의 합 : 2(100(99 + 98 + ... + 1) + 99(98 + 97 + ... + 1) + ... + 3(2 + 1) + 2)
	- 공차가 1인 등차수열의 합
		- 1 + 2 + 3 + ... + n = n(n + 1) / 2

### 2014/11/21

#### 조재우
- Swift
		- **문제 3번 풀이 완료** 1시간
- 회고 : 예비군 때문에 좀 쉬었다가 Swift 로 풀다보니 조금 헤멨다. 소수가 2를 제외하고 홀수라는 점, 예전에 루비로 풀었을땐 다른 방법으로 풀었는데 이번엔 좀 간단히 문제를 풀었다. 루비 코드 분석해서 적용하려다 시간이 좀 오래 걸림. 결국 나중에 소수 문제 다시 나오면 그 문제로 해보기로 했다. arrayMax 함수 구현하면서 arr.reduce(Int.min, { max($0, $1)}) 형태의 함수를 만들었다. 루비의 arr.inject(:+) 와 비슷해보이는 클로저 형태의 구현인데.. 자세한 원리는 좀 더 공부해봐야겠다.

#### 이대명
- Java
    - **문제 11번 풀이 완료** 2시간
- 회고
	- 주어진 문자열을 숫자로 파싱하여 특정 조건의 최대값을 구하는 문제이다.
	- 문자열을 통째로 받아서 정규표현식으로 int 배열에 파싱하려고 하다가 잘안되어 시간을 많이 날렸다. 
		- 정규표현식을 계속 찾아보며 파싱하려 하였지만 안되어서 split(" ") 함수를 이용하여 파싱하였다.
		- 파싱만 하면 단순 코딩 문제이다.
		- 루비로 할때 정규표현식으로 파싱했었는데, 자바랑 조금 달랐다.
	
#### 유병한
- Java
    - **문제 6번 풀이 완료** 1시간
- 회고
	- 소수판별 방법이 이해가 잘안되서 한참을 시간 보냈다.
	- 자연수 n 을 두 자연수 a, b(a <= b)의 곱으로 나타내면 n = a * b 와 같다. 이 때 a = b가 만족면 a = b = sqrt( n ) 이다. 따라서 a != b 이면 a와 b는 sqrt( n ) 보다 작은 수와 sqrt( n ) 보다 큰 수의 쌍이다. 이러한 원리에 의해 sqrt( n ) 보다 같거나 작은 수로 n을 나누어서 나누어 떨어지는 수가 없으면 sqrt( n ) 보다 큰 수에서도 n을 나눴을 때 나누어 떨어지는 수가 없게된다.
	- 정리하면 다음과 같다.
		- 자연수 n과 1보다 크고 sqrt( n ) 보다 같거나 작은 수 a에 대해 n 나누기 a를 했을 때 나누어 떨어지는 a가 존재 하지 않을 때 n은 소수이다.

### 2014/11/25

#### 조재우
- Swift
		- **문제 4번 풀이 완료** 48분
- 회고
	- Swift 에서 기본적으로 subString 관련 함수가 지원이 안되서 extension 으로 구현해서 쓰는 방법을 알아냈다. 루비처럼 오픈 클래스와 비슷한 형태로 extension 키워드와 subscript 키워드를 쓰는데.. 조금 어렵다.
	- palindrome 체크는 간단히 스트링으로 체크했다. 어려운 부분은 없었다.
	- getMaxPalindromes 구현하는데 실행 시간이 많이 걸린다. palindrome 체크가 실행시간의 대부분이므로 현재 n 의 제곱 실행 시간 (999x999) 인데 체크를 줄이기 위해 곱한값이 result 값보다 크지 않으면 브레이크를 걸었다. reverse 를 이용해서 뒤에서 부터 하는데 뒤 숫자 부터가 훨씬 더 큰 숫자를 가지고 있을 가능성이 크기 때문에 시간을 좀 더 줄일 수 있다. 하지만 아직도 swift 에서 테스트를 다 도는데 2초 가량 걸린다. 시간이 없어서 오늘은 일단 여기까지 하고 조금 더 고민해봐야겠다.

### 2014/11/26

#### 유병한
- Java
    - **문제 8번 풀이 완료** 1시간 15분
- 회고
	- 숫자를 문자열(String)으로 입력 받는다. 입력 받은 문자열을 순서대로 큐에 넣에 하나 씩 dequeue해 곱을 구한다.
	- 1000자리 중 5자리 씩 끊어 보는데 다섯 개씩 끊은 단위를 window로 정의했다. windowSize는 한 번에 끊어 보는 갯수이다.
	- Java collection 중 Queue를 구현하는 클래스에는 여러 가지가 있지만 이번 문제에서는 앞에서 계속 dequeue할 것이므로 LinkedList를 사용했다.

#### 조재우
- Swift
	- **문제 5번 풀이 완료** 2시간 33분 ㅋㅋ;
- 회고
	- 문제 아이디어 내는 건 40분 정도 걸렸다.
	- 예전에 루비로 풀었을때는 gcd, lcm 반복해서 풀었는데 이번엔 "무식하게 풀기" -> "소수 체크?" -> "최소 공배수, 최대 공약수" 까지 고민하다가 좀 다른 방법을 고민. 
	- 여러 개의 숫자를 최소 공배수 구할때 (1~10) 일때 2520 인데 이 숫자는 2^3 * 3^2 * 5 * 7 이다. 이건 1~10 사이에 공유되는 소수의 최고 차수들의 곱이다. 2의 최고 차수는 3인 8, 3의 최고 차수 2인 8, 나머지는 5, 7 이다.
	- 이런 방법으로 여러 번 끄적 거리다보니 1,2,3,4,5,6,7,8,9,10 을 가로로 놓고 첫번째 인덱스부터 나누면서 나눠지는 값을 저장하면 최소 공배수 값이 구해진다는 결론을 얻었다.
		- 예를들어,
		- 1,2,3,4,5,6,7,8,9,10 의 첫번째는 1 인데 1로 나눠서 나눠지는 값의 몫만 저장하면 그대로 1,2,3,4,5,6,7,8,9,10
		- 두번째는 2인데 2로 나눠서 나눠지는 값의 몫만 저장하면 1,1,3,2,5,3,7,4,9,5 
		- 세번째는 3 -> 1,1,1,2,5,1,7,4,3,5
		- 네번째는 원래는 4인데 두번째에서 2로 나눠져서 2이다. 2 -> 1,1,1,1,5,1,7,2,3,5
		- 5 -> 1,1,1,1,1,1,7,4,3,1
		- 6번째는 1이라서 그대로
		- 7 -> 1,1,1,1,1,1,1,2,3,1
		- 2 -> 1,1,1,1,1,1,1,1,3,1
		- 3 -> 1,1,1,1,1,1,1,1,1,1
		- 1
		- 이런식으로 각각 나누는 숫자를 가져오면 1,2,3,2,5,1,7,2,3,1 => 2 - 3개, 3 - 2개, 5 - 1개, 7 - 1개 이다. 즉 **2^3 * 3^2 * 5 * 7** 이 된다.
	- continuousNumbersLCM(max: Int) 메서드에 10을 넘고 확인하고 로직을 짠 후에 20을 넣으니 바로 답이 나왔다. (앞서 작성된 다른 테스트(메서드)는 모두 삭제해버렸다.)
	- 시간이 오래 걸린 이유
		- if i == j { divisor = arr[i] } 이 부분에서 다음 인덱스를 참조할때 이미 나눠진 값을 계속 나누려고 해서 위 과정에서 두번째일때 2를 전 배열에서 나눠야하는데 한번 for 문이 돌면 해당 인덱스 값이 1로 바뀌니까 1로 계속 나누는 상황이 발생했다. 문제 다 풀어놓고 디버깅하면서 멘붕의 소용돌이에 빠져서 2시간 가까이 삽질.. ㅠ 머릿속으로 코드를 돌리는 연습이 부족하다.. 코딩 연습 많이 하자.

### 2014/11/27
#### 이대명
- Java
    - **문제 12번 풀이 완료** 2시간
- 회고
	- 주어진 숫자의 약수의 갯수를 구하는 문제이다.
	- 처음에 1 부터 그 숫자까지 for 문을 돌면서 나누어 0 이되는 숫자를 다 모아 갯수를 체크 하였다. 그렇게 하니 시간이 엄청 길게 되어 다음날 다시 풀었다.
	- 본래 약수의 갯수를 구하는 공식이 숫자를 소인수분해 하여 나눈 지수들의 +1 의 곱이다.
		- 2^3 * 3^2  이라면 약수의 갯수는 (3+1) * (2+1) 하여 12개 이다.
	- 이렇게 할려다가 원래 햇었던 1부터 포문 도는 것중에 나누어 떨어 지는게 쌍으로 있으니 쌍으로 넣어 갯수를 체크하면 되지 않을까 생각 하였다. 총 반복 횟수가 sqrt 제곱근으로 확 줄어드니 갠찮은 방법 같았고 해보니 0.28초 가량 걸렸다.

### 2014/11/28
#### 이대명
- Java
    - **문제 13번 풀이 완료** 1시간 50분
- 회고
	- 주어진 100개의 숫자의 총합을 구하는 문제이다.
	- 처음에 문제를 잘못 이해하여 뒷 10자리 합을 구하는 건지 알고 그렇게 풀었다가, 앞 10자리 를 구하는 것을 알아 약간 멘붕이 되었었다. 
	- 하지만 뒷 10자리를 구한것을 바탕으로 뒷 10자리 합에서 10자리가 넘어가는 올림수( 캐리 )를 구하여 뒷 10자리부터 20자리까지의 합에 캐리를 더해주고 뒷 20자리 부터 30자리 까지 또 그 앞의 캐리를 더해주고 하여 앞의 10자리의 합 까지 구할수 있었다. 
	- 배열 선언하는데 있어서 미숙한 부분이 많았다. 선언 밑 초기화 익숙해 지자.
	- 문자열 파싱하는데 subString, split 를 이용하였다.

### 2014/12/10
#### 이대명
- Java
    - **문제 14번 풀이 완료** 2시간 00분
- 회고
	- 시간이 생각 보다 많이 걸렸는데, 처음했던 방식으로 답이 나왔는데 정답이 아니라서 다시 풀었다.
	- 처음에 했던 방법이 거꾸로 올라가는 거 였다.
		1 -> 2 -> 4 -> 8 -> 16 -> (32, 5) .....
		이전 숫자에서 - 1 했을때 3의 배수이면 홀수일 경우와 짝수일 경우로 두개가 나오는데 홀수일 경우로 올라가서 숫자가 작아지게 하여 최대의 시행착오를 격을 거라고 생각 하여 하였다. 이렇게 하여 답을 구했는데 답이 아니라고 떠서 문제에서 주어진대로 풀어보았다.
	- 두번째 방법으로 문제에서 주어진대로 풀어, 1000000 부터 시작하여 차례려 내려오면서 숫자를 전부 리스트에 저장해 그 리스트의 사이즈를 이용하여 최대 사이즈를 구하였다.
		처음 이방법으로 할려고 했는데, 컴파일 시간이 오래걸릴것 같아서 다른방법으롷 해볼려고 했었다.
		하지만 이방법으로 했을때 2초 정도 걸렸다.

### 2014/12/11

#### 유병한
- Java
    - **문제 10번 풀이 완료** 30분
- 회고
	- 소수 구하는 문제였다. 지난번에 풀었던 문제여서 크게 어려운 점은 없었다.
		